实现了有限状态传感器，有以下特性: 
- 构建最小FST的过程快速且内存消耗低(但是输入必须有序)
- 全部用byte[]表示，反序列化快速且 Object的额外消耗低
- two-pass 压缩: FST.pack() ？？？
- 支持按Output查找,如果Output是有序的话
- 可插拔的Outputs表示法
- N-最短路径
- Enumerators (IntsRef and BytesRef) that behave like SortedMap iterators ？？？ 

http://blog.mikemccandless.com/search?q=FST  
http://blog.mikemccandless.com/2010/12/using-finite-state-transducers-in.html  

输入	输出  
mop		0	  
moth	1	  
pop		2  
star	3  
stop	4  
top		5  

沿着输入的字符遍历所有的Arc，就可以得到输出  
输出可以是数字，字节序列... 它是可插拔的

本质上，FST是一个SortedMap<字节序列, 输出>,   
如果arc是有序的,则FST需要的内存比SortedMap少得多, 但是查询时更耗CPU  
FST的内存消耗少，这对Lucene是至关重要的，因为索引中可能有大量的Term   

增量构建最小的无权FST 