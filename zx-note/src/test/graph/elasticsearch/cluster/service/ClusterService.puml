@startuml

note left of ClusterService
5.6.4版本中的ClusterService，在后续版本被拆分成<b>MasterService</b>和<b>ClusterApplierService</b>：
MasterService只有主节点会执行这个类中的方法，即只有主节点会提交集群状态更改的任务。
主节点和从节点都会应用集群状态，因此都会执行ClusterApplierService中的方法。

Applier和 Listener的区别：
如果某个模块需要处理集群状态的变化，则调用addStateApplier添加一个<b>处理器</b>
如果某个模块需要监听集群状态的变化，则调用addStateListener添加一个<b>监听器</b>
Applier负责将集群状态应用到组件内部，对Applier的调用在集群状态可见之前(ClusterService#state())
对Listener的通知在新的集群状态可见之后。

线程池类型为PrioritizedEsThreadPoolExecutor, 在单个线程中执行，支持优先级。
end note

class ClusterService{
    ---
    // 三种优先级的集群状态更改
    -Collection<ClusterStateApplier> highPriorityStateAppliers
    -Collection<ClusterStateApplier> normalPriorityStateAppliers
    -Collection<ClusterStateApplier> lowPriorityStateAppliers
    -AtomicReference<ClusterState> state // 最新的集群状态
    -PrioritizedEsThreadPoolExecutor threadPoolExecutor // 执行任务的线程池
    -NodeConnectionsService nodeConnectionsService
    -OperationRouting operationRouting
    // 发布集群任务的模块
    - BiConsumer<ClusterChangedEvent, Discovery.AckListener> clusterStatePublisher
    ---
    以下方法在后续版本被拆分到MasterService中：
    // 待执行的任务数量
    +int numberOfPendingTasks()
    // 待执行的任务列表
    +List<PendingClusterTask> pendingTasks()
    // 提交集群层面的任务
    void submitStateUpdateTask(...)
    ---
    以下方法在后续版本被拆分到ClusterApplierService中：
    // 添加一个对集群状态的处理器
    +void addStateApplier(ClusterStateApplier applier)
    // 添加一个集群状态监听器
    +void addListener(ClusterStateListener listener)
    // 返回当前的集群状态
    +ClusterState state()
    // 各个模块调用这个方法提交一个集群状态更新的任务
    + .. submitStateUpdateTask(..)
}

class ClusterSettings{
    // 封装了所有Cluster级别的设置
    ---

}

interface ClusterStateApplier{
    ---
    // 当接收到一个新的集群状态时
    // 应用此方法来修改本地的集群状态
    +void applyClusterState(ClusterChangedEvent event)
}

class ClusterState implements Diffable{
    // 集群状态。 不可变对象。
    // 只能通过master来进行更新，所有更新操作由单个线程顺序执行
    // 每次更新完毕后。由Discovery.publish方法通知其他结点。
    // 实现Diffable接口，可以只发送增量
    ---
    -String stateUUID // 增量更新时需比较的版本id
    -ClusterName clusterName
    -RoutingTable routingTable
    -DiscoveryNodes nodes
    -MetaData metaData
    -ClusterBlocks blocks
}

class MetaData{
    集群元数据。
    详见cluster.metadata包
}

class RoutingTable{
    // 每一个索引中的每一个分片，处在哪一个节点上
    // 见elasticsearch.cluster.routing包
}

class DiscoveryNodes{
    // 集群中所有的节点
    // 见elasticsearch.cluster.node包
}

class ClusterBlocks{
    // 表示集群级别的阻塞，用来阻止对集群的脏操作
    // 见elasticsearch.cluster.block包
}

class NodeConnectionsService{
    // 负责连接到其他节点（当节点加入集群时）
    // 或者断开到其他节点的连接（当节点从集群被移除时）
    // 内部依赖org.elasticsearch.transport.TransportService来实现功能
    ---
    +void connectToNodes(DiscoveryNodes discoveryNodes)
    +void disconnectFromNodesExcept(DiscoveryNodes nodesToKeep)
}

class OperationRouting{
    // 路由操作
    ---
    // 用get 获取文档时的路由函数，指定了id 和 routing值
    +ShardIterator getShards(ClusterState clusterState, String index, String id, @Nullable String routing, @Nullable String preference)
    // 用get 获取文档时的路由函数， 指定了shardId
    +ShardIterator getShards(ClusterState clusterState, String index, int shardId, @Nullable String preference)
    // 写入文档时的路由函数
    +ShardIterator indexShards(ClusterState clusterState, String index, String id, @Nullable String routing)
    // search查询时的路由函数
    +GroupShardsIterator<ShardIterator> searchShards(ClusterState clusterState, String[] concreteIndices, @Nullable Map<String, Set<String>> routing, @Nullable String preference)
    +ShardId shardId(ClusterState clusterState, String index, String id, @Nullable String routing)
}

ClusterService *-- ClusterSettings

ClusterService *- DiscoverySettings

ClusterService *---- OperationRouting

ClusterService "1" *-- "n" ClusterStateApplier

ClusterService *-- ClusterState

ClusterService *-- NodeConnectionsService

ClusterState *-- RoutingTable

ClusterState *-- DiscoveryNodes

ClusterState *-- MetaData

ClusterState *-- ClusterBlocks



@enduml